security:
  # Configuration des hashers de mot de passe
  password_hashers:
    # Spécifie que les mots de passe des utilisateurs qui implémentent PasswordAuthenticatedUserInterface seront hachés avec l'algorithme choisi ici
    Symfony\Component\Security\Core\User\PasswordAuthenticatedUserInterface:
      algorithm: auto  # Symfony choisit automatiquement l'algorithme de hachage (généralement bcrypt ou argon2, dans le projet bcrypt est utilisé)
      cost: 15  # Détermine le coût de l'algorithme de hachage (complexité)

  # Configuration du fournisseur d'utilisateurs (d'où proviennent les utilisateurs pour l'authentification)
  providers:
    app_user_provider:
      entity:
        class: App\Entity\User  # Indique que les utilisateurs viennent de l'entité User
        property: email  # Utilise l'email pour retrouver les utilisateurs dans la base de données

  # Définition des firewalls (protection des routes de l'application)
  firewalls:
    # Configuration du firewall pour les routes de développement, comme les outils de débogage et les ressources statiques (CSS, JS, etc.)
    dev:
      pattern: ^/(_(profiler|wdt)|css|images|js)/  # Ce motif couvre les routes liées au profiler, aux fichiers CSS, JS et images
      security: false  # Pas de sécurité appliquée sur ces routes (les utilisateurs peuvent y accéder sans être authentifiés)

# Configuration pour les API (commentée ici, mais peut être activée si nécessaire pour les connexions API basées sur JSON ou JWT)
    api:
      pattern: ^/api/login
      stateless: true
      json_login:
        check_path: /api/login  # La route où les identifiants sont envoyés
        username_path: email          # Le champ JSON pour l'email
        password_path: password       # Le champ JSON pour le mot de passe
        success_handler: lexik_jwt_authentication.handler.authentication_success  # Gestionnaire de succès (pour JWT)
        failure_handler: lexik_jwt_authentication.handler.authentication_failure  # Gestionnaire d'échec
      # jwt: ~  # Active la vérification des tokens JWT pour les autres routes
    
    api_delete:
      pattern: ^/comment/api/delete
      stateless: true
      jwt: ~  # Active la vérification des tokens JWT pour cette route

    # Configuration principale du firewall pour toutes les autres routes
    main:
      pattern: ^/  # Cela couvre toutes les routes qui commencent par '/' (toutes les routes de l'application)
      provider: app_user_provider  # Utilise le fournisseur d'utilisateurs défini ci-dessus
      form_login:  # Authentification par formulaire
        login_path: app_login  # La route pour afficher le formulaire de connexion
        check_path: /login  # La route où les informations de connexion sont envoyées via une requête POST
        default_target_path: /article  # Après une connexion réussie, l'utilisateur est redirigé vers la page /users
      logout:  # Gestion de la déconnexion
        path: /logout  # La route pour se déconnecter

  # Configuration des contrôles d'accès (qui peut accéder à quelles routes en fonction de son rôle)
  access_control:
    # Autorise l'accès à la page de connexion sans être authentifié
    - { path: ^/login, roles: PUBLIC_ACCESS }  # La page /login est publique (tout le monde peut y accéder)

    # Autorise l'accès à la page de déconnexion sans être authentifié
    - { path: ^/logout, roles: PUBLIC_ACCESS }  # La page /logout est publique (tout le monde peut y accéder)

    # Autorise l'accès à la page d'inscription sans être authentifié
    - { path: ^/users/new, roles: PUBLIC_ACCESS }  # La page /users/new (inscription) est publique (tout le monde peut y accéder)

    # Restreint l'accès à la page des utilisateurs (/users) uniquement aux utilisateurs complètement authentifiés
    - { path: ^/users/list, roles: ROLE_ADMIN }  # L'accès à la page /users/list est restreint aux utilisateurs qui sont admin

    - { path: ^/categorie, roles: ROLE_ADMIN }

    - { path: ^/article/, roles: PUBLIC_ACCESS }

    - { path: ^/article/new, roles: IS_AUTHENTICATED_FULLY }

    - { path: ^/api/login, roles: PUBLIC_ACCESS }  # La route de login est publique

    - { path: ^/comment/api/delete, roles: IS_AUTHENTICATED_FULLY }  # Toutes les autres routes API nécessitent une authentification

    # - { path: ^/api/login, roles: PUBLIC_ACCESS }

    # - { path: ^/api/admin, roles: ROLE_ADMIN }

monolog:
    channels: ['security']
    handlers:
        security:
            type: stream
            path: "%kernel.logs_dir%/security.log"
            level: debug


